shader_type spatial;
render_mode diffuse_toon, depth_prepass_alpha;

group_uniforms Albedo;
uniform float wall_threshold : hint_range(0.0, 0.5) = 0.0;
uniform ivec3 chunk_size = ivec3(33, 32, 33);
uniform vec4 ground_albedo : source_color = vec4(0.392, 0.471, 0.318, 1.0);
uniform vec4 ground_albedo_2 : source_color = vec4(0.322, 0.482, 0.384, 1.0);
uniform vec4 ground_albedo_3 : source_color = vec4(0.373, 0.424, 0.294, 1.0);
uniform vec4 ground_albedo_4 : source_color = vec4(0.392, 0.475, 0.255, 1.0);
uniform vec4 ground_albedo_5 : source_color = vec4(0.29, 0.494, 0.365, 1.0);
uniform vec4 ground_albedo_6 : source_color = vec4(0.443, 0.447, 0.365, 1.0);
uniform vec4 wall_albedo : source_color = vec4(0.369, 0.337, 0.271, 1.0);
uniform vec4 wall_albedo_2 : source_color = vec4(0.4, 0.35, 0.28, 1.0);
uniform vec4 wall_albedo_3 : source_color = vec4(0.35, 0.32, 0.25, 1.0);
uniform vec4 wall_albedo_4 : source_color = vec4(0.38, 0.34, 0.27, 1.0);
uniform vec4 wall_albedo_5 : source_color = vec4(0.36, 0.33, 0.26, 1.0);
uniform vec4 wall_albedo_6 : source_color = vec4(0.42, 0.38, 0.30, 1.0);
group_uniforms;

group_uniforms Wall_Textures;
uniform sampler2D wall_tex_1 : source_color, repeat_enable;
uniform sampler2D wall_tex_2 : source_color, repeat_enable;
uniform sampler2D wall_tex_3 : source_color, repeat_enable;
uniform sampler2D wall_tex_4 : source_color, repeat_enable;
uniform sampler2D wall_tex_5 : source_color, repeat_enable;
uniform sampler2D wall_tex_6 : source_color, repeat_enable;
group_uniforms;

group_uniforms Blending;
// true = Original behavior (single material, hard edges, works with "Perfect Square Tiles")
// false = Smooth blending between materials (works with "Mixed Triangles")
uniform bool use_hard_square_edges = false;
uniform float blend_sharpness : hint_range(0.0, 5.0, 0.1) = 2.5;
uniform float blend_noise_scale : hint_range(0.0, 50.0, 1.0) = 10.0;
uniform float blend_noise_strength : hint_range(0.0, 1.0, 0.05) = 0.0;
group_uniforms;

group_uniforms Height_Blending;
uniform bool use_height_blend = false;
uniform float height_blend_strength : hint_range(0.0, 1.0, 0.05) = 0.5;
uniform float height_low : hint_range(-50.0, 50.0, 0.5) = 0.0;
uniform float height_mid : hint_range(-50.0, 50.0, 0.5) = 5.0;
uniform float height_high : hint_range(-50.0, 50.0, 0.5) = 10.0;
uniform float height_transition_smoothness : hint_range(0.1, 5.0, 0.1) = 1.0;
uniform int material_low : hint_range(0, 15) = 0;
uniform int material_mid : hint_range(0, 15) = 1;
uniform int material_high : hint_range(0, 15) = 2;
uniform float height_noise_strength : hint_range(0.0, 5.0, 0.1) = 1.0;
group_uniforms;

group_uniforms Vertex_Colors;
uniform sampler2D vc_tex_rr : source_color;
uniform sampler2D vc_tex_rg : source_color;
uniform sampler2D vc_tex_rb : source_color;
uniform sampler2D vc_tex_ra : source_color;
uniform sampler2D vc_tex_gr : source_color;
uniform sampler2D vc_tex_gg : source_color;
uniform sampler2D vc_tex_gb : source_color;
uniform sampler2D vc_tex_ga : source_color;
uniform sampler2D vc_tex_br : source_color;
uniform sampler2D vc_tex_bg : source_color;
uniform sampler2D vc_tex_bb : source_color;
uniform sampler2D vc_tex_ba : source_color;
uniform sampler2D vc_tex_ar : source_color;
uniform sampler2D vc_tex_ag : source_color;
uniform sampler2D vc_tex_ab : source_color;
uniform sampler2D vc_tex_aa : source_color;
group_uniforms;

group_uniforms Shading;
uniform vec4 shadow_color : source_color;
uniform int bands : hint_range(1, 10) = 5;
uniform float shadow_intensity : hint_range(-1.0, 0.5, 0.05) = 0.00;
group_uniforms;

// Shared varyings
varying vec3 vertex_normal;
varying vec4 custom1;
varying vec3 world_pos;

// Hard edges mode: flat material index (no interpolation)
varying flat int material_index;

// Soft blend mode: interpolated vertex colors
varying vec4 vc_color_0;
varying vec4 vc_color_1;

float hash(vec2 p) {
	return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	f = f * f * (3.0 - 2.0 * f);
	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));
	return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p, int octaves) {
	float value = 0.0;
	float amplitude = 0.5;
	float frequency = 1.0;
	for (int i = 0; i < octaves; i++) {
		value += amplitude * noise(p * frequency);
		amplitude *= 0.5;
		frequency *= 2.0;
	}
	return value;
}

// Original: Get material index from vertex colors (used in vertex shader for hard edges)
int get_material_index(vec4 vc_col_0, vec4 vc_col_1) {
	int index = 0;
	if (vc_col_0.r > 0.1) {
		if (vc_col_1.r > 0.1) index = 0;
		else if (vc_col_1.g > 0.1) index = 1;
		else if (vc_col_1.b > 0.1) index = 2;
		else if (vc_col_1.a > 0.1) index = 3;
	}
	else if (vc_col_0.g > 0.1) {
		if (vc_col_1.r > 0.1) index = 4;
		else if (vc_col_1.g > 0.1) index = 5;
		else if (vc_col_1.b > 0.1) index = 6;
		else if (vc_col_1.a > 0.1) index = 7;
	}
	else if (vc_col_0.b > 0.1) {
		if (vc_col_1.r > 0.1) index = 8;
		else if (vc_col_1.g > 0.1) index = 9;
		else if (vc_col_1.b > 0.1) index = 10;
		else if (vc_col_1.a > 0.1) index = 11;
	}
	else if (vc_col_0.a > 0.1) {
		if (vc_col_1.r > 0.1) index = 12;
		else if (vc_col_1.g > 0.1) index = 13;
		else if (vc_col_1.b > 0.1) index = 14;
		else if (vc_col_1.a > 0.1) index = 15;
	}
	return index;
}

// Sample material by index with albedo tints applied
vec4 sample_material_by_index(int index, vec2 uv) {
	vec4 result;
	switch(index) {
		case 0: result = texture(vc_tex_rr, uv) * ground_albedo; break;
		case 1: result = texture(vc_tex_rg, uv) * ground_albedo_2; break;
		case 2: result = texture(vc_tex_rb, uv) * ground_albedo_3; break;
		case 3: result = texture(vc_tex_ra, uv) * ground_albedo_4; break;
		case 4: result = texture(vc_tex_gr, uv) * ground_albedo_5; break;
		case 5: result = texture(vc_tex_gg, uv) * ground_albedo_6; break;
		case 6: result = texture(vc_tex_gb, uv); break;
		case 7: result = texture(vc_tex_ga, uv); break;
		case 8: result = texture(vc_tex_br, uv); break;
		case 9: result = texture(vc_tex_bg, uv); break;
		case 10: result = texture(vc_tex_bb, uv); break;
		case 11: result = texture(vc_tex_ba, uv); break;
		case 12: result = texture(vc_tex_ar, uv); break;
		case 13: result = texture(vc_tex_ag, uv); break;
		case 14: result = texture(vc_tex_ab, uv); break;
		case 15: result = texture(vc_tex_aa, uv); break;
		default: result = texture(vc_tex_rr, uv) * ground_albedo; break;
	}
	return result;
}

// Sample wall material by index (for hard edges mode and soft blend mode)
vec4 sample_wall_by_index(int index, vec2 uv) {
	vec4 result;
	switch(clamp(index, 0, 5)) {
		case 0: result = texture(wall_tex_1, uv) * wall_albedo; break;
		case 1: result = texture(wall_tex_2, uv) * wall_albedo_2; break;
		case 2: result = texture(wall_tex_3, uv) * wall_albedo_3; break;
		case 3: result = texture(wall_tex_4, uv) * wall_albedo_4; break;
		case 4: result = texture(wall_tex_5, uv) * wall_albedo_5; break;
		case 5: result = texture(wall_tex_6, uv) * wall_albedo_6; break;
		default: result = texture(wall_tex_1, uv) * wall_albedo; break;
	}
	return result;
}

// ============================================================================
// BLENDING FUNCTIONS (for soft blend mode)
// ============================================================================

void calculate_blend_weights(vec4 vc0, vec4 vc1, float sharpness, out float weights[16]) {
	// Calculate raw weights from vertex color products
	float raw_weights[16];
	raw_weights[0]  = vc0.r * vc1.r;
	raw_weights[1]  = vc0.r * vc1.g;
	raw_weights[2]  = vc0.r * vc1.b;
	raw_weights[3]  = vc0.r * vc1.a;
	raw_weights[4]  = vc0.g * vc1.r;
	raw_weights[5]  = vc0.g * vc1.g;
	raw_weights[6]  = vc0.g * vc1.b;
	raw_weights[7]  = vc0.g * vc1.a;
	raw_weights[8]  = vc0.b * vc1.r;
	raw_weights[9]  = vc0.b * vc1.g;
	raw_weights[10] = vc0.b * vc1.b;
	raw_weights[11] = vc0.b * vc1.a;
	raw_weights[12] = vc0.a * vc1.r;
	raw_weights[13] = vc0.a * vc1.g;
	raw_weights[14] = vc0.a * vc1.b;
	raw_weights[15] = vc0.a * vc1.a;

	// Apply sharpness via power function
	float power = 1.0 + sharpness * 2.0;
	float total = 0.0;

	for (int i = 0; i < 16; i++) {
		weights[i] = pow(max(raw_weights[i], 0.0), power);
		total += weights[i];
	}

	// Normalize weights
	if (total > 0.001) {
		for (int i = 0; i < 16; i++) {
			weights[i] /= total;
		}
	} else {
		// Fallback: find dominant material
		float max_raw = 0.0;
		int max_idx = 0;
		for (int i = 0; i < 16; i++) {
			if (raw_weights[i] > max_raw) {
				max_raw = raw_weights[i];
				max_idx = i;
			}
		}
		for (int i = 0; i < 16; i++) {
			weights[i] = (i == max_idx) ? 1.0 : 0.0;
		}
	}
}

// Blend wall materials using vertex color weights (for soft blend mode)
vec4 blend_wall_materials(vec2 uv, vec4 vc0, vec4 vc1, float sharpness) {
	float weights[16];
	calculate_blend_weights(vc0, vc1, sharpness, weights);

	// Map 16 ground slots to 6 wall slots (clamp to 0-5)
	vec4 wall_color = vec4(0.0);
	float total_weight = 0.0;

	for (int i = 0; i < 16; i++) {
		if (weights[i] > 0.01) {
			int wall_idx = clamp(i, 0, 5);  // Map to wall slots 0-5
			wall_color += sample_wall_by_index(wall_idx, uv) * weights[i];
			total_weight += weights[i];
		}
	}

	if (total_weight > 0.001) {
		wall_color /= total_weight;
	}
	return wall_color;
}

// ============================================================================
// HEIGHT BLENDING FUNCTIONS
// ============================================================================

void calculate_height_weights(float height, vec2 noise_pos, out float low_weight, out float mid_weight, out float high_weight) {
	float height_noise = fbm(noise_pos * blend_noise_scale * 0.3, 3) * 2.0 - 1.0;
	float h = height + height_noise * height_noise_strength;
	
	float low_to_mid = height_low + (height_mid - height_low) * 0.5;
	float mid_to_high = height_mid + (height_high - height_mid) * 0.5;
	float transition_size = height_transition_smoothness;
	
	low_weight = 1.0 - smoothstep(height_low - transition_size * 0.5, low_to_mid + transition_size * 0.5, h);
	high_weight = smoothstep(mid_to_high - transition_size * 0.5, height_high + transition_size * 0.5, h);
	mid_weight = max(1.0 - low_weight - high_weight, 0.0);
	
	float total = low_weight + mid_weight + high_weight;
	if (total > 0.0) {
		low_weight /= total;
		mid_weight /= total;
		high_weight /= total;
	}
}

// ============================================================================
// VERTEX SHADER
// ============================================================================

void vertex() {
	vertex_normal = NORMAL;
	custom1 = CUSTOM1;
	world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	
	// Hard edges: calculate material index here (flat = no interpolation)
	material_index = get_material_index(COLOR, CUSTOM0);
	
	// Soft blend: pass interpolated vertex colors to fragment
	vc_color_0 = COLOR;
	vc_color_1 = CUSTOM0;
}

// ============================================================================
// FRAGMENT SHADER
// ============================================================================

void fragment() {
	vec2 tiling_factor_floor = vec2(1.0 / float(chunk_size.x), 1.0 / float(chunk_size.z));
	vec2 tiling_factor_wall = vec2(1.0 / float(chunk_size.x), 1.0 / float(chunk_size.y));
	float is_ridge = custom1.g;
	bool is_floor = dot(vertex_normal, vec3(0.0, 1.0, 0.0)) > wall_threshold && is_ridge < 0.5;

	if (is_floor) {
		vec2 floor_uv = UV2 * tiling_factor_floor;
		vec4 floor_color;

		//Hard edges mode keeps original behaviour 
		if (use_hard_square_edges) {
			floor_color = sample_material_by_index(material_index, floor_uv);
		}
		
		//Soft Blend mode applicable when we have triangules
		else {
			// Apply noise to sharpness for organic edges
			float effective_sharpness = blend_sharpness;
			if (blend_noise_strength > 0.0) {
				float n = noise(world_pos.xz * blend_noise_scale);
				effective_sharpness = mix(blend_sharpness, blend_sharpness * (0.5 + n), blend_noise_strength);
			}

			// Calculate blend weights
			float weights[16];
			calculate_blend_weights(vc_color_0, vc_color_1, effective_sharpness, weights);

			// Sample and blend materials
			floor_color = vec4(0.0);
			float total_weight = 0.0;
			for (int i = 0; i < 16; i++) {
				if (weights[i] > 0.01) {
					floor_color += sample_material_by_index(i, floor_uv) * weights[i];
					total_weight += weights[i];
				}
			}
			if (total_weight > 0.001) {
				floor_color /= total_weight;
			}
		}

		// HEIGHT BLENDING (Optional, works with both modes) - Can remove it not in the Roadmap...
		if (use_height_blend) {
			float low_w, mid_w, high_w;
			calculate_height_weights(world_pos.y, world_pos.xz, low_w, mid_w, high_w);

			vec4 height_color = vec4(0.0);
			if (low_w > 0.01) height_color += sample_material_by_index(material_low, floor_uv) * low_w;
			if (mid_w > 0.01) height_color += sample_material_by_index(material_mid, floor_uv) * mid_w;
			if (high_w > 0.01) height_color += sample_material_by_index(material_high, floor_uv) * high_w;

			floor_color = mix(floor_color, height_color, height_blend_strength);
		}

		ALBEDO = floor_color.rgb;
		ALPHA = floor_color.a;
	}
	else {
		// Wall/Ridge rendering with dual-mode support
		vec4 vertex_pos = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
		vec3 abs_normal = abs(vertex_normal);

		vec3 tri_weights = vec3(abs_normal.x, 0.0, abs_normal.z);
		tri_weights /= (tri_weights.x + tri_weights.z);

		vec2 uv_x = vertex_pos.zy * tiling_factor_wall * 2.0;
		vec2 uv_z = vertex_pos.xy * tiling_factor_wall * 2.0;

		vec4 wall_mat_x, wall_mat_z;

		if (use_hard_square_edges) {
			// Hard edges: single material based on vertex material_index
			wall_mat_x = sample_wall_by_index(material_index, uv_x);
			wall_mat_z = sample_wall_by_index(material_index, uv_z);
		} else {
			// Soft blend: blend wall materials based on vertex colors
			float effective_sharpness = blend_sharpness;
			if (blend_noise_strength > 0.0) {
				float n = noise(world_pos.xz * blend_noise_scale);
				effective_sharpness = mix(blend_sharpness, blend_sharpness * (0.5 + n), blend_noise_strength);
			}
			wall_mat_x = blend_wall_materials(uv_x, vc_color_0, vc_color_1, effective_sharpness);
			wall_mat_z = blend_wall_materials(uv_z, vc_color_0, vc_color_1, effective_sharpness);
		}

		vec3 texture_x = wall_mat_x.rgb * tri_weights.x;
		vec3 texture_z = wall_mat_z.rgb * tri_weights.z;

		ALBEDO = texture_x + texture_z;
	}
}

void light() {
	float NdotL = dot(NORMAL, LIGHT);
	NdotL = clamp(NdotL, 0.0, 1.0);

	float stepped = ceil(NdotL * float(bands)) / float(bands);
	float toon_light = mix(shadow_intensity, 0.3, stepped);
	toon_light *= ATTENUATION;

	vec3 light_color = mix(shadow_color.rgb, LIGHT_COLOR.rgb, toon_light);
	DIFFUSE_LIGHT += light_color;
}